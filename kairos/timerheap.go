package kairos

// A timerHeap is a binary heap containing all running Timers, ordered by their expiration times.
type timerHeap []*Timer

func (h timerHeap) Peek() *Timer { return h.idx(0) }
func (h *timerHeap) Insert(t *Timer) {
	t.i = h.Len()
	*h = append(*h, t)
	h.siftUp(t.i)
}

func (h *timerHeap) Remove(t *Timer) bool {
	// t may not be registered anymore and may have a bogus i (typically 0, if generated by Go).
	// Verify it before proceeding.
	if h.idx(t.i) != t {
		return false
	}
	i := t.i
	last := h.Len() - 1
	if i != last {
		(*h)[i] = (*h)[last]
		(*h)[i].i = i
	}
	(*h)[last] = nil
	*h = (*h)[:last]
	if i != last {
		h.siftUp(i)
		h.siftDown(i)
	}
	t.i = -1 // mark as removed
	return true
}

func (h timerHeap) idx(i int) *Timer {
	if i < 0 || i >= h.Len() {
		return nil
	}
	return h[i]
}

func (h timerHeap) Len() int { return len(h) }

// Heap maintenance algorithms.
// Based on golang source /runtime/time.go

func (h timerHeap) siftUp(i int) {
	tmp := h[i]
	when := tmp.when

	var p int
	for i > 0 {
		p = (i - 1) / 4 // parent
		if !when.Before(h[p].when) {
			break
		}
		h[i] = h[p]
		h[i].i = i
		h[p] = tmp
		h[p].i = p
		i = p
	}
}

func (h timerHeap) siftDown(i int) {
	n := h.Len()
	when := h[i].when
	tmp := h[i]
	for {
		c := i*4 + 1 // left child
		c3 := c + 2  // mid child
		if c >= n {
			break
		}
		w := h[c].when
		if c+1 < n && h[c+1].when.Before(w) {
			w = h[c+1].when
			c++
		}
		if c3 < n {
			w3 := h[c3].when
			if c3+1 < n && h[c3+1].when.Before(w3) {
				w3 = h[c3+1].when
				c3++
			}
			if w3.Before(w) {
				w = w3
				c = c3
			}
		}
		if !w.Before(when) {
			break
		}
		h[i] = h[c]
		h[i].i = i
		h[c] = tmp
		h[c].i = c
		i = c
	}
}
