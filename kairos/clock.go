package kairos

import (
	"sync"
	"time"
)

var realClock = newClock()

type clock struct {
	rescheduleC chan struct{}
	mutex       sync.Mutex // protects:
	timers      *timerHeap
}

func newClock() *clock {
	clk := &clock{rescheduleC: make(chan struct{}, 1), timers: &timerHeap{}}
	go clk.timerRoutine()
	return clk
}

// NewTimer creates a new [Timer] and starts it with duration d.
func (clk *clock) NewTimer(d time.Duration) *Timer {
	t := clk.NewStoppedTimer()
	clk.addTimer(t, d)
	return t
}

// NewStoppedTimer creates a new stopped [Timer].  Call [Timer.Reset] to start it.
func (clk *clock) NewStoppedTimer() *Timer {
	c := make(chan time.Time, 1)
	return &Timer{C: c, c: c}
}

// Add the timer to the heap.
func (clk *clock) addTimer(t *Timer, d time.Duration) {
	t.when = time.Now().Add(d)

	clk.mutex.Lock()
	clk.addTimerLocked(t)
	clk.mutex.Unlock()
}

func (clk *clock) addTimerLocked(t *Timer) {
	clk.timers.Insert(t)
	// Reschedule if this is the next timer in the heap.
	if clk.timers.Peek() == t {
		clk.reschedule()
	}
}

// Delete timer t from the heap.
// It returns true if t was removed, false if t wasn't even there.
// Do not need to update the timer routine: if it wakes up early, no big deal.
func (clk *clock) delTimer(t *Timer) (b bool) {
	clk.mutex.Lock()
	b = clk.delTimerLocked(t)
	clk.mutex.Unlock()
	return
}

// Delete timer t from the heap.
// It returns true if t was removed, false if t wasn't even there.
// Do not need to update the timer routine: if it wakes up early, no big deal.
func (clk *clock) delTimerLocked(t *Timer) bool {
	return clk.timers.Remove(t)
}

// Reset the timer to the new timeout duration.
// This clears the channel.
func (clk *clock) resetTimer(t *Timer, d time.Duration) (b bool) {
	clk.mutex.Lock()
	b = clk.delTimerLocked(t)
	// The channel must be drained while the mutex is locked, otherwise a notification generated by a
	// concurrent t.Reset(0) call might be erroneously consumed.
	select {
	case <-t.C:
	default:
	}
	t.when = time.Now().Add(d)
	clk.addTimerLocked(t)
	clk.mutex.Unlock()
	return
}

func (clk *clock) reschedule() {
	// Do not block if there is already a pending reschedule request.
	select {
	case clk.rescheduleC <- struct{}{}:
	default:
	}
}

func (clk *clock) timerRoutine() {
	var now time.Time

	sleepTimer := time.NewTimer(0)
	<-sleepTimer.C
	sleepTimerActive := false

Loop:
	for {
		select {
		case <-sleepTimer.C:

		case <-clk.rescheduleC:
			// If not yet received a value from sleepTimer.C, the timer must be
			// stopped and—if Stop reports that the timer expired before being
			// stopped—the channel explicitly drained.
			if !sleepTimer.Stop() && sleepTimerActive {
				<-sleepTimer.C
			}
		}
		sleepTimerActive = false

	Reschedule:
		now = time.Now()

		clk.mutex.Lock()
		if clk.timers.Len() == 0 {
			clk.mutex.Unlock()
			continue Loop
		}

		t := clk.timers.Peek()
		delta := t.when.Sub(now)

		// Sleep if not expired.
		if delta > 0 {
			clk.mutex.Unlock()
			sleepTimer.Reset(delta)
			sleepTimerActive = true
			continue Loop
		}

		// Timer expired.
		select {
		case t.c <- now:
		default:
		}

		// Remove from heap.
		clk.delTimerLocked(t)

		clk.mutex.Unlock()

		// Reschedule immediately.
		goto Reschedule
	}
}
