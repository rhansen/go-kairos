package kairos

import (
	"sync"
	"time"
)

var (
	rescheduleC = make(chan struct{}, 1)
	mutex       sync.Mutex // protects:
	timers      = &timerHeap{}
)

func init() {
	go timerRoutine()
}

// Add the timer to the heap.
func addTimer(t *Timer, d time.Duration) {
	t.when = time.Now().Add(d)

	mutex.Lock()
	addTimerLocked(t)
	mutex.Unlock()
}

func addTimerLocked(t *Timer) {
	timers.Insert(t)
	// Reschedule if this is the next timer in the heap.
	if timers.Peek() == t {
		reschedule()
	}
}

// Delete timer t from the heap.
// It returns true if t was removed, false if t wasn't even there.
// Do not need to update the timer routine: if it wakes up early, no big deal.
func delTimer(t *Timer) (b bool) {
	mutex.Lock()
	b = delTimerLocked(t)
	mutex.Unlock()
	return
}

// Delete timer t from the heap.
// It returns true if t was removed, false if t wasn't even there.
// Do not need to update the timer routine: if it wakes up early, no big deal.
func delTimerLocked(t *Timer) bool {
	return timers.Remove(t)
}

// Reset the timer to the new timeout duration.
// This clears the channel.
func resetTimer(t *Timer, d time.Duration) (b bool) {
	mutex.Lock()
	b = delTimerLocked(t)
	// The channel must be drained while the mutex is locked, otherwise a notification generated by a
	// concurrent t.Reset(0) call might be erroneously consumed.
	select {
	case <-t.C:
	default:
	}
	t.when = time.Now().Add(d)
	addTimerLocked(t)
	mutex.Unlock()
	return
}

func reschedule() {
	// Do not block if there is already a pending reschedule request.
	select {
	case rescheduleC <- struct{}{}:
	default:
	}
}

func timerRoutine() {
	var now time.Time

	sleepTimer := time.NewTimer(0)
	<-sleepTimer.C
	sleepTimerActive := false

Loop:
	for {
		select {
		case <-sleepTimer.C:

		case <-rescheduleC:
			// If not yet received a value from sleepTimer.C, the timer must be
			// stopped and—if Stop reports that the timer expired before being
			// stopped—the channel explicitly drained.
			if !sleepTimer.Stop() && sleepTimerActive {
				<-sleepTimer.C
			}
		}
		sleepTimerActive = false

	Reschedule:
		now = time.Now()

		mutex.Lock()
		if timers.Len() == 0 {
			mutex.Unlock()
			continue Loop
		}

		t := timers.Peek()
		delta := t.when.Sub(now)

		// Sleep if not expired.
		if delta > 0 {
			mutex.Unlock()
			sleepTimer.Reset(delta)
			sleepTimerActive = true
			continue Loop
		}

		// Timer expired.
		select {
		case t.c <- now:
		default:
		}

		// Remove from heap.
		delTimerLocked(t)

		mutex.Unlock()

		// Reschedule immediately.
		goto Reschedule
	}
}
